/**
 * @fileoverview Firestore Security Rules for MedConnect Platform
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for patient and doctor data,
 * ensuring that only authenticated users can access their own profile information.
 * It also provides public read access to doctor listings to facilitate discovery,
 * while restricting write access to doctor profiles to the respective doctor.
 * Appointments and health records are secured under the owning patient or doctor, 
 * and WebRTC call signaling data is accessible to any authenticated user to facilitate call setup.
 *
 * Data Structure:
 * - /patients/{patientId}: Patient profile information, accessible only by the patient.
 * - /doctors/{doctorId}: Doctor profile information, accessible only by the doctor. Publicly listable.
 * - /patients/{patientId}/appointments/{appointmentId}: Appointments for a specific patient, accessible only by the patient.
 * - /doctors/{doctorId}/appointments/{appointmentId}: Appointments for a specific doctor, accessible only by the doctor.
 * - /patients/{patientId}/healthRecords/{healthRecordId}: Health records for a specific patient, accessible only by the patient.
 * - /calls/{callId}: WebRTC call signaling data, accessible to any authenticated user.
 * - /calls/{callId}/offerCandidates/{candidateId}: ICE candidates from the caller, accessible to any authenticated user.
 * - /calls/{callId}/answerCandidates/{candidateId}: ICE candidates from the callee, accessible to any authenticated user.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed except for the /doctors collection, which is publicly readable.
 * - Ambiguous relationships default to strict owner-only access.
 * - Public read access to doctors aims to support an open directory.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants access to patient profile information.
     * @path /patients/{patientId}
     * @allow (create, update, get, delete, list) if the user is the owner (patientId matches auth.uid).
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @deny (create, update, get, delete) if the patientId does not match auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if false;

      allow create: if isOwner(patientId) && request.resource.data.id == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Grants access to doctor profile information.
     * @path /doctors/{doctorId}
     * @allow (create, update, get, delete) if the user is the owner (doctorId matches auth.uid).
     * @allow (list) to all users.
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @deny (create, update, get, delete) if the doctorId does not match auth.uid.
     * @principle Enforces document ownership for writes, but allows public reads.
     */
    match /doctors/{doctorId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get, list: if true;

      allow create: if isOwner(doctorId) && request.resource.data.id == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Grants access to appointments associated with a specific patient.
     * @path /patients/{patientId}/appointments/{appointmentId}
     * @allow (create, update, get, delete) if the user is the owner (patientId matches auth.uid).
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @deny (create, update, get, delete) if the patientId does not match auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId}/appointments/{appointmentId} {
      function isOwner(patientId) {
        return request.auth != null && request.auth.uid == patientId;
      }
      function isExistingOwner(patientId) {
        return isOwner(patientId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);

      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Grants access to appointments associated with a specific doctor.
     * @path /doctors/{doctorId}/appointments/{appointmentId}
     * @allow (create, update, get, delete) if the user is the owner (doctorId matches auth.uid).
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @deny (create, update, get, delete) if the doctorId does not match auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /doctors/{doctorId}/appointments/{appointmentId} {
      function isOwner(doctorId) {
        return request.auth != null && request.auth.uid == doctorId;
      }
      function isExistingOwner(doctorId) {
        return isOwner(doctorId) && resource != null;
      }

      allow get: if isOwner(doctorId);
      allow list: if isOwner(doctorId);

      allow create: if isOwner(doctorId) && request.resource.data.doctorId == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.doctorId == resource.data.doctorId;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Grants access to health records associated with a specific patient.
     * @path /patients/{patientId}/healthRecords/{healthRecordId}
     * @allow (create, update, get, delete) if the user is the owner (patientId matches auth.uid).
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @deny (create, update, get, delete) if the patientId does not match auth.uid.
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId}/healthRecords/{healthRecordId} {
      function isOwner(patientId) {
        return request.auth != null && request.auth.uid == patientId;
      }
      function isExistingOwner(patientId) {
        return isOwner(patientId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);

      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Grants access to WebRTC call signaling data for any authenticated user.
     * @path /calls/{callId}
     * @allow (create, update, get, delete) to any authenticated user.
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @principle Allows any authenticated user to create, read, update, and delete call data.
     */
    match /calls/{callId} {
       function isSignedIn() {
         return request.auth != null;
       }

      allow get, list, create, update, delete: if isSignedIn();
    }

    /**
     * @description Grants access to ICE candidates from the caller for any authenticated user.
     * @path /calls/{callId}/offerCandidates/{candidateId}
     * @allow (create, update, get, delete) to any authenticated user.
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @principle Allows any authenticated user to create, read, update, and delete offer candidates.
     */
    match /calls/{callId}/offerCandidates/{candidateId} {
       function isSignedIn() {
         return request.auth != null;
       }

      allow get, list, create, update, delete: if isSignedIn();
    }

    /**
     * @description Grants access to ICE candidates from the callee for any authenticated user.
     * @path /calls/{callId}/answerCandidates/{candidateId}
     * @allow (create, update, get, delete) to any authenticated user.
     * @deny (create, update, get, delete) if the user is not authenticated.
     * @principle Allows any authenticated user to create, read, update, and delete answer candidates.
     */
    match /calls/{callId}/answerCandidates/{candidateId} {
       function isSignedIn() {
         return request.auth != null;
       }

      allow get, list, create, update, delete: if isSignedIn();
    }
  }
}