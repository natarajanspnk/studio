/**
 * @fileoverview Firestore Security Rules for MediConnect Platform
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model, ensuring that only authenticated users can access their own data. Doctor and Patient profile information is secured by path-based ownership,
 * while appointment and health records are stored in user-specific subcollections, further restricting access.
 *
 * Data Structure:
 * - /patients/{patientId}: Stores patient profile information, accessible only by the patient.
 * - /doctors/{doctorId}: Stores doctor profile information, accessible only by the doctor.
 * - /patients/{patientId}/appointments/{appointmentId}: Stores appointments for a specific patient, accessible only by the patient.
 * - /doctors/{doctorId}/appointments/{appointmentId}: Stores appointments for a specific doctor, accessible only by the doctor.
 * - /patients/{patientId}/healthRecords/{healthRecordId}: Stores health records for a specific patient, accessible only by the patient.
 *
 * Key Security Decisions:
 * - User data is segregated under dedicated /patients/{patientId} and /doctors/{doctorId} paths.
 * - Appointments are duplicated as subcollections of both patients and doctors to allow for efficient querying.
 * - No user listing is allowed to prevent unauthorized data access.
 * - Data consistency between the document ID and the path parameters is enforced on create.
 * - Attempts to modify the document ID after creation are denied.
 *
 * Denormalization for Authorization:
 * The `patientId` and `doctorId` are inherently denormalized through the document path, enabling simple ownership checks without requiring additional `get()` calls.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secures patient profile information.
     * @path /patients/{patientId}
     * @allow (create) - Authenticated user with UID matching the patientId can create their profile.
     * @allow (get, update, delete) - Authenticated user with UID matching the patientId can access or modify their profile.
     * @deny (create) - Authenticated user with UID not matching the patientId cannot create a profile for another user.
     * @deny (get, update, delete) - Authenticated user with UID not matching the patientId cannot access or modify another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /patients/{patientId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return isSignedIn() && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if false;
      allow create: if isOwner(patientId) && request.resource.data.id == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Secures doctor profile information.
     * @path /doctors/{doctorId}
     * @allow (create) - Authenticated user with UID matching the doctorId can create their profile.
     * @allow (get, update, delete) - Authenticated user with UID matching the doctorId can access or modify their profile.
     * @deny (create) - Authenticated user with UID not matching the doctorId cannot create a profile for another user.
     * @deny (get, update, delete) - Authenticated user with UID not matching the doctorId cannot access or modify another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /doctors/{doctorId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(doctorId) {
        return isSignedIn() && request.auth.uid == doctorId;
      }

      function isExistingOwner(doctorId) {
        return isOwner(doctorId) && resource != null;
      }

      allow get: if isOwner(doctorId);
      allow list: if false;
      allow create: if isOwner(doctorId) && request.resource.data.id == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Secures appointments associated with a specific patient.
     * @path /patients/{patientId}/appointments/{appointmentId}
     * @allow (create, get, update, delete) - Authenticated user with UID matching the patientId can manage their appointments.
     * @deny (create, get, update, delete) - Authenticated user with UID not matching the patientId cannot manage appointments for other patients.
     * @principle Enforces document ownership for writes within a subcollection.
     */
    match /patients/{patientId}/appointments/{appointmentId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(patientId) {
        return isSignedIn() && request.auth.uid == patientId;
      }

       function isExistingOwner(patientId) {
        return isOwner(patientId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);
      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }

     /**
     * @description Secures appointments associated with a specific doctor.
     * @path /doctors/{doctorId}/appointments/{appointmentId}
     * @allow (create, get, update, delete) - Authenticated user with UID matching the doctorId can manage their appointments.
     * @deny (create, get, update, delete) - Authenticated user with UID not matching the doctorId cannot manage appointments for other doctors.
     * @principle Enforces document ownership for writes within a subcollection.
     */
    match /doctors/{doctorId}/appointments/{appointmentId} {
       function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(doctorId) {
        return isSignedIn() && request.auth.uid == doctorId;
      }

       function isExistingOwner(doctorId) {
        return isOwner(doctorId) && resource != null;
      }

      allow get: if isOwner(doctorId);
      allow list: if isOwner(doctorId);
      allow create: if isOwner(doctorId) && request.resource.data.doctorId == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.doctorId == resource.data.doctorId;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Secures health records associated with a specific patient.
     * @path /patients/{patientId}/healthRecords/{healthRecordId}
     * @allow (create, get, update, delete) - Authenticated user with UID matching the patientId can manage their health records.
     * @deny (create, get, update, delete) - Authenticated user with UID not matching the patientId cannot manage health records for other patients.
     * @principle Enforces document ownership for writes within a subcollection.
     */
    match /patients/{patientId}/healthRecords/{healthRecordId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(patientId) {
        return isSignedIn() && request.auth.uid == patientId;
      }

      function isExistingOwner(patientId) {
        return isOwner(patientId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);
      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }
  }
}