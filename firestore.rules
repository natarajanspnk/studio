/**
 * @fileoverview Firestore Security Rules for MedConnect Platform
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for patient and doctor data,
 * ensuring that only authenticated users can access their own profile information.
 * It also provides open access for authenticated users for WebRTC call signaling data.
 *
 * Data Structure:
 * - /patients/{patientId}: Stores patient profiles. Only the patient can access.
 * - /doctors/{doctorId}: Stores doctor profiles. Only the doctor can access.
 * - /patients/{patientId}/appointments/{appointmentId}: Appointments for a patient.
 * - /doctors/{doctorId}/appointments/{appointmentId}: Appointments for a doctor.
 * - /patients/{patientId}/healthRecords/{healthRecordId}: Health records for a patient.
 * - /calls/{callId}: Stores WebRTC call signaling data.
 * - /calls/{callId}/offerCandidates/{candidateId}: ICE candidates from the caller.
 * - /calls/{callId}/answerCandidates/{candidateId}: ICE candidates from the callee.
 *
 * Key Security Decisions:
 * - Patients and Doctors can only access their own profile data based on their unique ID.
 * - Appointments are stored as subcollections of both patients and doctors, each accessible only by the respective owner.
 * - Health Records are stored as a subcollection of a patient and are only accessible by the patient.
 * - The /doctors collection is NOT listable.
 * - WebRTC call signaling data is openly accessible for authenticated users.
 *
 * Denormalization for Authorization:
 * - The design uses path-based ownership and subcollections, which eliminates the need for `get()` calls in security rules,
 * simplifying the rule structure and improving performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows access to patient profile information only to the authenticated user with matching patientId.
     * @path /patients/{patientId}
     * @allow (create, update, get, delete) User with ID 'patient123' can create/update/get/delete their own patient document at /patients/patient123 when authenticated.
     * @deny (create, update, get, delete) User with ID 'anotherUser' cannot access patient data at /patients/patient123.
     * @principle Enforces document ownership for writes and reads.
     */
    match /patients/{patientId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if false;

      allow create: if isOwner(patientId) && request.resource.data.id == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Allows access to doctor profile information only to the authenticated user with matching doctorId.
     * @path /doctors/{doctorId}
     * @allow (create, update, get, delete) User with ID 'doctor456' can create/update/get/delete their own doctor document at /doctors/doctor456 when authenticated.
     * @deny (create, update, get, delete) User with ID 'anotherUser' cannot access doctor data at /doctors/doctor456.
     * @principle Enforces document ownership for writes and reads.
     */
    match /doctors/{doctorId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(doctorId);
      allow list: if false;

      allow create: if isOwner(doctorId) && request.resource.data.id == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Allows access to appointments associated with a specific patient.
     * @path /patients/{patientId}/appointments/{appointmentId}
     * @allow (create, update, get, delete) User with ID 'patient123' can create/update/get/delete appointment documents under /patients/patient123/appointments/{appointmentId}.
     * @deny (create, update, get, delete) User with ID 'anotherUser' cannot access appointments under /patients/patient123/appointments/{appointmentId}.
     * @principle Enforces document ownership for writes and reads.
     */
    match /patients/{patientId}/appointments/{appointmentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);

      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Allows access to appointments associated with a specific doctor.
     * @path /doctors/{doctorId}/appointments/{appointmentId}
     * @allow (create, update, get, delete) User with ID 'doctor456' can create/update/get/delete appointment documents under /doctors/doctor456/appointments/{appointmentId}.
     * @deny (create, update, get, delete) User with ID 'anotherUser' cannot access appointments under /doctors/doctor456/appointments/{appointmentId}.
     * @principle Enforces document ownership for writes and reads.
     */
    match /doctors/{doctorId}/appointments/{appointmentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(doctorId);
      allow list: if isOwner(doctorId);

      allow create: if isOwner(doctorId) && request.resource.data.doctorId == doctorId;
      allow update: if isExistingOwner(doctorId) && request.resource.data.doctorId == resource.data.doctorId;
      allow delete: if isExistingOwner(doctorId);
    }

    /**
     * @description Allows access to health records associated with a specific patient.
     * @path /patients/{patientId}/healthRecords/{healthRecordId}
     * @allow (create, update, get, delete) User with ID 'patient123' can create/update/get/delete health record documents under /patients/patient123/healthRecords/{healthRecordId}.
     * @deny (create, update, get, delete) User with ID 'anotherUser' cannot access health records under /patients/patient123/healthRecords/{healthRecordId}.
     * @principle Enforces document ownership for writes and reads.
     */
    match /patients/{patientId}/healthRecords/{healthRecordId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(patientId);
      allow list: if isOwner(patientId);

      allow create: if isOwner(patientId) && request.resource.data.patientId == patientId;
      allow update: if isExistingOwner(patientId) && request.resource.data.patientId == resource.data.patientId;
      allow delete: if isExistingOwner(patientId);
    }

    /**
     * @description Allows any authenticated user to create, read, update and delete call signaling data.
     * @path /calls/{callId}
     * @allow (create, get, list, update, delete) Any authenticated user can create/read/update/delete call documents.
     * @deny (create, get, list, update, delete) Unauthenticated users cannot access call documents.
     * @principle Open access for authenticated users.
     */
    match /calls/{callId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Allows any authenticated user to create, read, update and delete offer candidates.
     * @path /calls/{callId}/offerCandidates/{candidateId}
     * @allow (create, get, list, update, delete) Any authenticated user can create/read/update/delete offer candidate documents.
     * @deny (create, get, list, update, delete) Unauthenticated users cannot access offer candidate documents.
     * @principle Open access for authenticated users.
     */
    match /calls/{callId}/offerCandidates/{candidateId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Allows any authenticated user to create, read, update and delete answer candidates.
     * @path /calls/{callId}/answerCandidates/{candidateId}
     * @allow (create, get, list, update, delete) Any authenticated user can create/read/update/delete answer candidate documents.
     * @deny (create, get, list, update, delete) Unauthenticated users cannot access answer candidate documents.
     * @principle Open access for authenticated users.
     */
    match /calls/{callId}/answerCandidates/{candidateId} {
      function isSignedIn() {
        return request.auth != null;
      }
      allow get, list: if isSignedIn();
      allow create, update, delete: if isSignedIn();
    }
  }
}