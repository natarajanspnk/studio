/**
 * @fileoverview Firestore Security Rules for MedConnect platform.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for patient and doctor
 * data, ensuring that only the authenticated user can access their own profile
 * information. Appointments and health records are secured under the respective
 * user profiles. WebRTC call signaling data is publicly accessible to any
 * authenticated user.
 *
 * Data Structure:
 * - /patients/{patientId}: Patient profile information.
 * - /doctors/{doctorId}: Doctor profile information.
 * - /patients/{patientId}/appointments/{appointmentId}: Appointments for a patient.
 * - /doctors/{doctorId}/appointments/{appointmentId}: Appointments for a doctor.
 * - /patients/{patientId}/healthRecords/{healthRecordId}: Health records for a patient.
 * - /calls/{callId}: WebRTC call signaling data.
 * - /calls/{callId}/offerCandidates/{candidateId}: ICE candidates from the caller.
 * - /calls/{callId}/answerCandidates/{candidateId}: ICE candidates from the callee.
 *
 * Key Security Decisions:
 * - Patients and Doctors can only access their own profiles.
 * - Appointments are stored under both patient and doctor profiles for easy querying.
 * - Health records are stored under the patient's profile and are only accessible by the patient.
 * - WebRTC call signaling data is publicly accessible to authenticated users.
 * - No user listing is allowed for Patients and Doctors collection.
 *
 * Denormalization for Authorization:
 * - The data model denormalizes `patientId` and `doctorId` into appointment documents
 *   stored under both `/patients/{patientId}/appointments/{appointmentId}` and
 *   `/doctors/{doctorId}/appointments/{appointmentId}`. This duplication
 *   allows security rules to authorize access to appointments based on the
 *   parent path, without needing complex `get()` operations.
 *
 * Structural Segregation:
 * - Data for WebRTC calls are stored separately in the `/calls` collection
 *   with public read and write access for authenticated users. This segregation
 *   allows for a simplified security model without affecting the privacy of
 *   patient and doctor data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Restricts access to the 'doctors' collection. It only allows read access to all authenticated users. Write access is denied.
     * @path /databases/{database}/documents/doctors
     * @allow (get, list): if true
     * @deny (create, update, delete): if false
     * @principle Public read, no writes allowed.
     */
    match /doctors/{doctorId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Only allow patients to read and write their own profile data.
     * @path /databases/{database}/documents/patients/{patientId}
     * @allow (create, get, update, delete, list): if isSignedIn() && isOwner(patientId)
     * @deny (create): if !isOwner(patientId)
     * @deny (get, update, delete, list): if !isOwner(patientId)
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId} {
      allow get, list: if isOwner(patientId);
      allow create: if isOwner(patientId);
      allow update: if isOwner(patientId) && resource.data.id == patientId;
      allow delete: if isOwner(patientId) && resource != null;
    }

    /**
     * @description Only allow doctors to read and write their own profile data.
     * @path /databases/{database}/documents/doctors/{doctorId}
     * @allow (create, get, update, delete, list): if isSignedIn() && isOwner(doctorId)
     * @deny (create): if !isOwner(doctorId)
     * @deny (get, update, delete, list): if !isOwner(doctorId)
     * @principle Enforces document ownership for all operations.
     */
    match /doctors/{doctorId} {
      allow get, list: if isOwner(doctorId);
      allow create: if isOwner(doctorId);
      allow update: if isOwner(doctorId) && resource.data.id == doctorId;
      allow delete: if isOwner(doctorId) && resource != null;
    }

    /**
     * @description Only allow a patient to manage their own appointments.
     * @path /databases/{database}/documents/patients/{patientId}/appointments/{appointmentId}
     * @allow (create, get, update, delete, list): if isSignedIn() && isOwner(patientId)
     * @deny (create): if !isOwner(patientId)
     * @deny (get, update, delete, list): if !isOwner(patientId)
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId}/appointments/{appointmentId} {
      allow get, list: if isOwner(patientId);
      allow create: if isOwner(patientId);
      allow update: if isOwner(patientId) && resource != null;
      allow delete: if isOwner(patientId) && resource != null;
    }

    /**
     * @description Only allow a doctor to manage their own appointments.
     * @path /databases/{database}/documents/doctors/{doctorId}/appointments/{appointmentId}
     * @allow (create, get, update, delete, list): if isSignedIn() && isOwner(doctorId)
     * @deny (create): if !isOwner(doctorId)
     * @deny (get, update, delete, list): if !isOwner(doctorId)
     * @principle Enforces document ownership for all operations.
     */
    match /doctors/{doctorId}/appointments/{appointmentId} {
      allow get, list: if isOwner(doctorId);
      allow create: if isOwner(doctorId);
      allow update: if isOwner(doctorId) && resource != null;
      allow delete: if isOwner(doctorId) && resource != null;
    }

    /**
     * @description Only allow a patient to manage their own health records.
     * @path /databases/{database}/documents/patients/{patientId}/healthRecords/{healthRecordId}
     * @allow (create, get, update, delete, list): if isSignedIn() && isOwner(patientId)
     * @deny (create): if !isOwner(patientId)
     * @deny (get, update, delete, list): if !isOwner(patientId)
     * @principle Enforces document ownership for all operations.
     */
    match /patients/{patientId}/healthRecords/{healthRecordId} {
      allow get, list: if isOwner(patientId);
      allow create: if isOwner(patientId);
      allow update: if isOwner(patientId) && resource != null;
      allow delete: if isOwner(patientId) && resource != null;
    }

    /**
     * @description Allows any authenticated user to create or join a call.
     * @path /databases/{database}/documents/calls/{callId}
     * @allow (create, get, update, delete, list): if isSignedIn()
     * @principle Open access for authenticated users to facilitate call setup.
     */
    match /calls/{callId} {
      allow get, list, create, update, delete: if isSignedIn();
    }

    /**
     * @description Allows any authenticated user to add ICE candidates from the caller.
     * @path /databases/{database}/documents/calls/{callId}/offerCandidates/{candidateId}
     * @allow (create, get, update, delete, list): if isSignedIn()
     * @principle Open access for authenticated users to facilitate call setup.
     */
    match /calls/{callId}/offerCandidates/{candidateId} {
      allow get, list, create, update, delete: if isSignedIn();
    }

    /**
     * @description Allows any authenticated user to add ICE candidates from the callee.
     * @path /databases/{database}/documents/calls/{callId}/answerCandidates/{candidateId}
     * @allow (create, get, update, delete, list): if isSignedIn()
     * @principle Open access for authenticated users to facilitate call setup.
     */
    match /calls/{callId}/answerCandidates/{candidateId} {
      allow get, list, create, update, delete: if isSignedIn();
    }
  }

  // Helper function to determine if the user is signed in
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the document
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  // Helper function to determine if the user is the existing owner of the document
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}